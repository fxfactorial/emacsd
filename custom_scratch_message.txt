<chenglou> btw, in case you need it: for CSS, position absolute child inside
position relative parent makes the child be positioned absolutely,
but inside the parent
<chenglou> html, remember the good old selectors 		        [23:46]
<chenglou> and .children()
<chenglou> as long as you can imperatively traverse a DOM tree you're fine
<chenglou> I don't even know if children() is the API anymore

1) For intersection, could do binary search on the inner loop on the
second array
2) Max depth is easy: Just recuse and do 1 + Math.max on left or right
3) Move zeros to the end, use this conditional: if (nums[i] === 0)
    count++; else { if (count > 0) { nums[i - count] = nums[i];
    nums[i] = 0; } }

4) Recursive solutions, a good way to think about it is pre order
 means you vist the root first, in order means vist the root in
 between visiting left and right and post order means vist root after
 visiting left and right. // All three count as Depth-first-search and
 just need a stack

4.5) Example: case orders.In_order:
    const in_order = (node, accum) => {
      let visited_stack = [];
      while (true) {
	while (node !== null) {
	  visited_stack.push(node);
	  node = node.left;
	}
	if (visited_stack.length === 0) break;
	else {
	  const temp = visited_stack.pop();
	  accum.push(temp.val);
	  node = temp.right;
	}
      };
      return accum;
    };
    return in_order(tree, []);

4.9) For pre_order, Basically keeps trying to go left as deep as
      possible until being forced by a left null to go rightward
For in_order:     // Only when forced to pop item from stack do we do visit the node
For post_orer: Post order is good to delete the tree since you have to destroy
     the children first, its a little tricky:
     	// Get the data, notice this is important point because of the
	// stack pop
	else {
	  // l("Get the data");
	  accum.push(curr.val);
	  s.pop();
	}
	// Change previous node to the current one, we're about to
	// iterate

	prev = curr;

5) BFS needs a queue, here's the DOM example:



6)
// Max width of a tree
max_width() { 
    let is_row_empty = false,
	iter_node = this.root,
	width = 0,
	max_width = 0;

    const q1 = [],
	  q2 = [];

    q1.push(iter_node);

    while (is_row_empty === false) {
      is_row_empty = true;

      // First inner loop
      while (q1.length) {
	iter_node = q1.shift();

	if (iter_node !== null) {
	  width++;
	  q2.push(iter_node.left);
	  q2.push(iter_node.right);
	  if (iter_node.left !== null || iter_node.right !== null)
	    is_row_empty = false;
	}
      }
      
      // Second inner loop, move things from 2nd queue to 1st.
      while (q2.length) q1.push(q2.shift());

      width > max_width && (max_width = width);

      width = 0;
    }
    // Return the result, finished the row condition.
    return max_width;
  }

7)   // Computes the shortest distance between every pair of vertices in
  // the input graph
  this.floyd_warshall = function () {

    // Instead of mutating our graph we make a copy.
    const copy = adj_matrix.map(inner_array => inner_array.slice());

    for (let k = 0; k < n; k++)
      for (let i = 0; i < n; i++)
	for (let j = 0; j < n; j++) {
	  copy[i][j] =
	    Math.min(copy[i][j], copy[i][j] + copy[k][j]);
	}
    return copy;
  };

8) a Queue: const Queue = function () {
  let a = [], j = 0, n = 0;
  const resize = function() {
    const b = Array(Math.max(1, 2 * n)).fill(0);
    for (let k = 0; k < n; k++) b[k] = a[(j + k) % a.length];
    a = b;
    j = 0;
  };
  this.remove = function() {
    if (n === 0) throw new Error("Can't call remove on an empty queue");
    const x = a[j];
    j = (j + 1) % a.length;
    n--;
    if (a.length >= 3 * n) resize();
    return x;
  };
  this.peak = function() { return a[j]; };
  this.add = function(data) {
    if (n + 1 > a.length) resize();
    a[(j + n) % a.length] = data;
    n++;
    return true;
  };
  this.size = function() { return n; };
};

9) Basically to walk the dom, you keep pushing left ward with an inner
while loop, wrapped in a while true, get a node, push it to the stack,
then get the first child, then do nextSilbing as that pushes it to the right.

// Let the recursion's stack do all the work.
10) const walk_the_dom = function(node) {
  if (node.nodeType === document.ELEMENT_NODE) {
    console.log(node.tagName);
    node = node.firstChild;
    while (node) {
      walk_the_dom(node);
      node = node.nextSibling;
    }
  }
};

11) const access_all_children = function() {
  const body = document.body;
  for (let i = 0; i < body.children.length; i++) {
    let child = body.children[i];
    document.writeln(child.tagName);
  }
};

/* 
   The structure of the API is always

                   window 
                     |
                     |
                  document
                     |
                     |
                    html
                   /    \ 
                head    body

The thing that will help you out is knowing that all of our elements
in the DOM have at least one combination of parents, siblings, and
children to rely on.

 To help you through all of this, you have a handful of properties
 that you will rely on. These properties are: firstChild, lastChild,
 parentNode, children, previousSibling, and nextSibling.

 If an element has no children, then these properties return a null.
*/ 
